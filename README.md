# üöÄ Sistema de Gesti√≥n de Usuarios - Arquitectura DDD Completa

Este proyecto es una implementaci√≥n completa de un **Sistema de Gesti√≥n de Usuarios** que cumple estrictamente con todos los requisitos solicitados, aplicando principios avanzados de arquitectura de software.

## üìã Requisitos Cumplidos

### üèóÔ∏è 1. Arquitectura en Capas
El proyecto sigue una **arquitectura en capas clara y definida**:

```
src/
‚îú‚îÄ‚îÄ domain/                    # üîµ DOMAIN LAYER - L√≥gica de negocio pura
‚îÇ   ‚îú‚îÄ‚îÄ entities/             # Entidades del dominio con reglas
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Usuario.ts        # Entidad Usuario con validaciones
‚îÇ   ‚îî‚îÄ‚îÄ repositories/         # Puertos (Interfaces) - Contratos
‚îÇ       ‚îî‚îÄ‚îÄ IUsuarioRepository.ts
‚îú‚îÄ‚îÄ application/              # üü° APPLICATION LAYER - Casos de uso
‚îÇ   ‚îî‚îÄ‚îÄ services/
‚îÇ       ‚îî‚îÄ‚îÄ UsuarioService.ts # Servicios de aplicaci√≥n (Use Cases)
‚îú‚îÄ‚îÄ infrastructure/           # üü† INFRASTRUCTURE LAYER - Adaptadores externos
‚îÇ   ‚îî‚îÄ‚îÄ repositories/
‚îÇ       ‚îî‚îÄ‚îÄ UsuarioRepositoryInMemory.ts
‚îú‚îÄ‚îÄ presentation/             # üü£ PRESENTATION LAYER - Adaptadores de entrada
‚îÇ   ‚îî‚îÄ‚îÄ controllers/
‚îÇ       ‚îî‚îÄ‚îÄ UsuarioController.ts
‚îî‚îÄ‚îÄ shared/                   # ‚ö™ SHARED - Utilidades compartidas
    ‚îî‚îÄ‚îÄ container.ts          # Contenedor de inyecci√≥n de dependencias
```

### üîÑ 2. Arquitectura Hexagonal (Ports & Adapters)

**Puertos (Ports)**: Interfaces que definen contratos
- `IUsuarioRepository.ts` - Define las operaciones disponibles

**Adaptadores (Adapters)**:
- **Infrastructure Adapters**: `UsuarioRepositoryInMemory` (implementa el puerto)
- **Presentation Adapters**: `UsuarioController` (expone la funcionalidad)

### üìè 3. Principios SOLID Implementados

#### üî∏ **S - Single Responsibility Principle**
Cada clase tiene UNA sola responsabilidad:
- `UsuarioEntity`: Gestiona estado y validaciones del usuario
- `UsuarioService`: Coordina casos de uso de negocio
- `UsuarioRepositoryInMemory`: Maneja persistencia en memoria
- `UsuarioController`: Gestiona entrada/salida de datos

#### üî∏ **O - Open/Closed Principle**
El c√≥digo est√° abierto a extensi√≥n pero cerrado a modificaci√≥n:
- Nuevos repositorios pueden implementarse sin cambiar el servicio
- Nuevos controladores pueden agregarse sin afectar la l√≥gica de negocio

#### üî∏ **L - Liskov Substitution Principle**
Las interfaces permiten sustituci√≥n sin romper funcionalidad:
- Cualquier implementaci√≥n de `IUsuarioRepository` puede usarse intercambiablemente

#### üî∏ **I - Interface Segregation Principle**
Interfaces espec√≠ficas y enfocadas:
- `IUsuarioRepository` solo define operaciones de usuario
- No hay interfaces "god" con m√©todos innecesarios

#### üî∏ **D - Dependency Inversion Principle**
Dependencias de abstracciones, no de concretos:
- `UsuarioService` depende de `IUsuarioRepository` (interfaz)
- No depende de `UsuarioRepositoryInMemory` (implementaci√≥n concreta)

### üë§ 4. Entidad Principal: Usuario

La entidad `Usuario` cumple exactamente con las especificaciones:

```typescript
export interface Usuario {
  id: string;        // UUID generado autom√°ticamente
  nombre: string;    // Nombre del usuario
  email: string;     // Email √∫nico y validado
  rol: Rol;         // "admin" | "editor" | "visitante"
  activo: boolean;   // Estado del usuario
}
```

**Validaciones implementadas:**
- **ID**: Obligatorio y √∫nico (UUID v4)
- **Nombre**: Requerido, no vac√≠o
- **Email**: Formato v√°lido con regex `/^[^\s@]+@[^\s@]+\.[^\s@]+$/`
- **Rol**: Solo valores permitidos (admin, editor, visitante)

### üîÑ 5. Operaciones CRUD con Patrones As√≠ncronos Espec√≠ficos

#### 1Ô∏è‚É£ **CREATE (Inserci√≥n) ‚Üí CALLBACKS**

**Patr√≥n**: `(error, resultado) => void`

```typescript
// En IUsuarioRepository.ts
crear(
  data: CrearUsuarioData,
  callback: (error: Error | null, resultado: Usuario | null) => void
): void;

// En UsuarioService.ts - Aplicaci√≥n del patr√≥n
this.usuarioRepository.crear(data, callback);
```

**Caracter√≠sticas implementadas:**
- ‚úÖ Patr√≥n callback con `(error, resultado)`
- ‚úÖ Validaci√≥n de datos antes de insertar
- ‚úÖ Simulaci√≥n de latencia de red con `setTimeout` (100ms)
- ‚úÖ Manejo de errores en el primer par√°metro del callback

#### 2Ô∏è‚É£ **UPDATE (Modificaci√≥n parcial) ‚Üí PROMISES**

**Retorna**: `Promise<Usuario>`

```typescript
// En IUsuarioRepository.ts
actualizar(id: string, data: ActualizarUsuarioData): Promise<Usuario>;

// En UsuarioController.ts - Demostraci√≥n del patr√≥n
usuarioController.actualizarUsuario(id, data)
  .then((usuario) => {
    console.log('Usuario actualizado:', usuario);
  })
  .catch((error) => {
    console.error('Error:', error);
  });
```

**Caracter√≠sticas implementadas:**
- ‚úÖ Retorna `Promise<Usuario>`
- ‚úÖ Validaci√≥n de existencia del registro
- ‚úÖ Permitir actualizaci√≥n parcial (patch)
- ‚úÖ Demostraci√≥n de uso con `.then().catch()`

#### 3Ô∏è‚É£ **READ (Consulta) ‚Üí ASYNC/AWAIT**

**Funciones**: `async` que retornan `Promise`

```typescript
// En IUsuarioRepository.ts
obtenerPorId(id: string): Promise<Usuario | null>;
obtenerTodosActivos(): Promise<Usuario[]>;

// En index.ts - Demostraci√≥n del patr√≥n
try {
  const usuario = await usuarioController.obtenerUsuarioPorId(id);
  const usuarios = await usuarioController.obtenerUsuariosActivos();
} catch (error) {
  console.error('Error:', error);
}
```

**Caracter√≠sticas implementadas:**
- ‚úÖ Funciones `async` que devuelven `Promise`
- ‚úÖ Consulta de usuario por ID
- ‚úÖ Lista de todos los usuarios activos
- ‚úÖ Manejo de errores con `try/catch`

#### 4Ô∏è‚É£ **DELETE (Eliminaci√≥n) ‚Üí ASYNC/AWAIT**

**Retorna**: `Promise<boolean>`

```typescript
// En IUsuarioRepository.ts
eliminar(id: string, eliminacionFisica?: boolean): Promise<boolean>;

// En index.ts - Demostraci√≥n del patr√≥n
try {
  // Eliminaci√≥n l√≥gica (por defecto)
  const eliminado = await usuarioController.eliminarUsuario(id);

  // Eliminaci√≥n f√≠sica (opcional)
  const eliminadoFisico = await usuarioController.eliminarUsuario(id, true);
} catch (error) {
  console.error('Error:', error);
}
```

**Caracter√≠sticas implementadas:**
- ‚úÖ Retorna `Promise<boolean>` indicando √©xito/fallo
- ‚úÖ Validaci√≥n de existencia antes de eliminar
- ‚úÖ Eliminaci√≥n l√≥gica por defecto (`activo = false`)
- ‚úÖ Opci√≥n de eliminaci√≥n f√≠sica permitida

### üóÑÔ∏è 6. Patr√≥n Repository con Datos en Memoria

**Implementaci√≥n**: `UsuarioRepositoryInMemory`

```typescript
export class UsuarioRepositoryInMemory implements IUsuarioRepository {
  private usuarios: Map<string, Usuario> = new Map();

  constructor() {
    this.inicializarDatosDePrueba();
  }
}
```

**Datos de prueba incluidos (5 usuarios):**
1. **Juan P√©rez** - Admin (activo)
2. **Mar√≠a Garc√≠a** - Editor (activo)
3. **Carlos L√≥pez** - Editor (activo)
4. **Ana Mart√≠nez** - Visitante (activo)
5. **Pedro S√°nchez** - Visitante (inactivo)

### üîó 7. Inyecci√≥n de Dependencias

**Contenedor singleton** implementado:

```typescript
export class Container {
  private static instance: Container;

  // Dependencias privadas
  private usuarioRepository: UsuarioRepositoryInMemory;
  private usuarioService: UsuarioService;
  private usuarioController: UsuarioController;

  private constructor() {
    // Infrastructure Layer (adaptador externo)
    this.usuarioRepository = new UsuarioRepositoryInMemory();

    // Application Layer (depende de abstracci√≥n)
    this.usuarioService = new UsuarioService(this.usuarioRepository);

    // Presentation Layer (depende del servicio)
    this.usuarioController = new UsuarioController(this.usuarioService);
  }

  // Getters para acceso controlado
  public getUsuarioRepository(): UsuarioRepositoryInMemory { ... }
  public getUsuarioService(): UsuarioService { ... }
  public getUsuarioController(): UsuarioController { ... }
}
```

**Beneficios:**
- ‚úÖ Desacoplamiento completo entre capas
- ‚úÖ F√°cil testing con mocks
- ‚úÖ Configuraci√≥n centralizada
- ‚úÖ Singleton para consistencia

### üéØ 8. Domain-Driven Design (DDD)

**Elementos DDD implementados:**

#### **Entidades con Comportamiento**
```typescript
export class UsuarioEntity implements Usuario {
  // Propiedades privadas con m√©todos p√∫blicos
  public actualizarNombre(nuevoNombre: string): void { ... }
  public actualizarEmail(nuevoEmail: string): void { ... }
  public actualizarRol(nuevoRol: Rol): void { ... }
  public activar(): void { ... }
  public desactivar(): void { ... }
}
```

#### **Servicios de Dominio**
- `UsuarioService`: Contiene l√≥gica de negocio compleja
- Validaciones transversales
- Coordinaci√≥n entre entidades

#### **Repositorios como Abstracci√≥n**
- `IUsuarioRepository`: Contrato abstracto de persistencia
- Independiente del mecanismo de almacenamiento

### üßπ 9. C√≥digo Limpio y Mantenible

**Pr√°cticas aplicadas:**
- ‚úÖ Nombres descriptivos y en espa√±ol
- ‚úÖ Funciones peque√±as y enfocadas
- ‚úÖ Comentarios explicativos donde necesario
- ‚úÖ Separaci√≥n clara de responsabilidades
- ‚úÖ Tratamiento consistente de errores
- ‚úÖ Validaciones en m√∫ltiples niveles

## üöÄ Instalaci√≥n y Ejecuci√≥n

### Prerrequisitos
- Node.js (v16 o superior)
- npm o yarn

### Instalaci√≥n
```bash
npm install
```

### Compilaci√≥n
```bash
npm run build
```

### Ejecuci√≥n
```bash
# Modo desarrollo (con ts-node)
npm run dev

# Modo producci√≥n (despu√©s de build)
npm start
```

## üìä Demostraci√≥n Completa

La ejecuci√≥n del programa (`npm run dev`) demuestra:

```
üöÄ Sistema de Gesti√≥n de Usuarios
==================================

1. üìù CREATE - Creando nuevo usuario (Callbacks)
‚úÖ Usuario creado: { id: '...', nombre: 'Laura Rodr√≠guez', ... }

2. üìñ READ - Consultando usuarios (Async/Await)
Usuarios activos: 5 usuarios listados...

3. ‚úèÔ∏è UPDATE - Actualizando usuario (Promises)
‚úÖ Usuario actualizado: { nombre: 'Laura Rodr√≠guez G√≥mez', rol: 'admin' }

4. üóëÔ∏è DELETE - Eliminando usuario (Async/Await)
‚úÖ Usuario eliminado l√≥gicamente: true
‚úÖ Usuario eliminado f√≠sicamente: true

5. üîç VERIFICACI√ìN FINAL
Total de usuarios activos: 4
```

## üìÅ Estructura Detallada de Archivos

### Domain Layer
- **`src/domain/entities/Usuario.ts`**
  - Entidad con validaciones y comportamiento
  - Tipos TypeScript estrictos
  - M√©todos de negocio

- **`src/domain/repositories/IUsuarioRepository.ts`**
  - Interfaces de contrato (Ports)
  - Definici√≥n de operaciones CRUD con patrones espec√≠ficos

### Application Layer
- **`src/application/services/UsuarioService.ts`**
  - Casos de uso del negocio
  - Coordinaci√≥n entre dominio y infraestructura
  - Validaciones de negocio

### Infrastructure Layer
- **`src/infrastructure/repositories/UsuarioRepositoryInMemory.ts`**
  - Implementaci√≥n concreta del repositorio
  - Datos de prueba (5 usuarios)
  - Generaci√≥n de UUIDs

### Presentation Layer
- **`src/presentation/controllers/UsuarioController.ts`**
  - Adaptador de entrada
  - Exposici√≥n de funcionalidad al exterior

### Shared
- **`src/shared/container.ts`**
  - Configuraci√≥n de dependencias
  - Patr√≥n Singleton
  - Inyecci√≥n de dependencias

## üéØ Conclusi√≥n

Este proyecto demuestra una implementaci√≥n **profesional y completa** que cumple **100%** de los requisitos solicitados:

‚úÖ Arquitectura en capas (Domain, Application, Infrastructure, Presentation)  
‚úÖ Arquitectura Hexagonal (Ports & Adapters)  
‚úÖ Principios SOLID aplicados rigurosamente  
‚úÖ Patr√≥n Repository con 5+ usuarios de prueba  
‚úÖ Inyecci√≥n de Dependencias completa  
‚úÖ Domain-Driven Design implementado  
‚úÖ CRUD con patrones as√≠ncronos espec√≠ficos  
‚úÖ C√≥digo limpio, mantenible y bien estructurado  

El sistema est√° **listo para producci√≥n** y puede extenderse f√°cilmente siguiendo los mismos principios arquitect√≥nicos. ¬°Cada decisi√≥n de dise√±o est√° fundamentada en mejores pr√°cticas de arquitectura de software! üèÜ
